---
title: "LET'S PRACTICE Geovisualization and Spatial Analysis "
author: "Kim Antunez & Timothée Giraud"
date: "Massive spatial data: challenges in acquisition, treatment and use for territories"
output:
  unilur::tutorial_html_solution:
    toc: true
    toc_float: false
    toc_depth: 1
    solution_suffix: ""
    theme: journal
    highlight: kate
    css: css_file.css
    self_contained: no
    number_sections: no
    number_subsections: no
---

```{r setup-practical, child = '_setup.Rmd'}
```

```{r knitr_init, echo=FALSE, cache=FALSE, include=FALSE}
#remotes::install_github("koncina/unilur@dev")
library(stringr)
library(knitr)
## Global options
options(max.print="90")
opts_chunk$set(echo=TRUE,
	             cache=FALSE, #TRUE
               prompt=FALSE,
               tidy=FALSE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=90)
options(width = 90)

# no margins
knit_hooks$set(nm = function(before, options, envir){
  if (before){
    par(mar=c(0,0,0,0))
  }
})

# title margins
knit_hooks$set(sm = function(before, options, envir){
  if (before){
    par(mar=c(0,0,1.2,0))
  }
})


```

# Exercice 1 : Manipulate sf objects and associated data.frames

1. Load in R the iris[^1] map layer "iris_31.rds" of the french department called Haute-Garonne (numbered 31). Would the `sf::st_read` function also work? Why ?

[^1]: In French, IRIS is an acronym of ‘aggregated units for statistical information’. Their target sizes are 2000 residents per basic unit.

<details>
<summary style="color:orange;font-family:courier;font-size:150%"><b>CLUES</b></summary>
Use the `readRDS` function.
</details>

```{r, solution = TRUE}
library(sf)
iris_31 <- readRDS("../data/iris_31.rds")
# iris_31 <- st_read("../data/iris_31.rds")
```

```{block, solution = TRUE}
It would not work because iris_31 is not a shapefile but a file already R formatted. Simply load it with the `readRDS` function.
```

2. Display the basemap of department 31 with `plot(iris_31)`.
What do you notice ?


```{r, nm=TRUE, solution = TRUE}
plot(iris_31)
# We notice that R performs 3 graphs: one graph per variable in the sf file.
```


3. What is the role of the `sf::st_geometry` function? What solution do you propose then?

```{r, nm=TRUE, solution = TRUE}
# ?sf::st_geometry
# This function makes it possible to isolate the geography information of the sf object so that we put aside other variables (here CODE_IRIS, P14_POP and INSEE_COM).
plot(st_geometry(iris_31))
```

4. In which projection is the map layer? Map it with another projection.

```{block, box.title=" Information",box.type = "advice"}
Test the Azimuthal Equidistant projection with "crs="+proj=aeqd +lat_0=90 +lon_0=0" to see a clear difference and create a layer called "iris_31_aeqd".
```
<details>
<summary style="color:orange;font-family:courier;font-size:150%"><b>CLUES</b></summary>
Use the `sf::st_crs` function to guess the projection and `sf::st_transform` to change the projection.
</details>


```{r, nm=TRUE, eval=FALSE, solution = TRUE}
#?st_crs
st_crs(iris_31)
par(mar = c(0,0,0,0), mfrow = c(1,2))
plot(st_geometry(iris_31))
iris_31_aeqd <- st_transform(iris_31, crs="+proj=aeqd +lat_0=90 +lon_0=0")
plot(st_geometry(iris_31_aeqd))
```

```{r, nm=TRUE, echo=FALSE}
par(mar = c(0,0,0,0), mfrow = c(1,2))
plot(st_geometry(iris_31))
iris_31_aeqd <- st_transform(iris_31, crs="+proj=aeqd +lat_0=90 +lon_0=0")
plot(st_geometry(iris_31_aeqd))
```

5. Calculate the distance matrix between the 5 first iris of department 31. Do you get the same distance matrix if you are working on a layer projected in another projection?

```{block, box.title=" Information",box.type = "advice"}
Use map layers called "iris_31" and "iris_31_aeqd"
```

```{r, nm=TRUE, solution=TRUE}
mat <- st_distance(x = iris_31[1:5,], y = iris_31[1:5,])
mat

mat_aeqd <- st_distance(x = iris_31_aeqd[1:5,], y = iris_31_aeqd[1:5,])
mat_aeqd

identical(mat,mat_aeqd)
# The two matrices are different
```


6. Using the layer called "iris_31", create a new aggregated map layer called "com_31" which corresponds to the municipalities of department 31. Also keep in this new layer the information on the population in each municipality.

```{block, box.title=" Information",box.type = "advice"}
The map layer called "iris_31" contains the 5 digit codes of municipalities in its variable INSEE_COM and the 2014 population in its column P14_POP.
```

<details>
<summary style="color:orange;font-family:courier;font-size:150%"><b>CLUES</b></summary>
Use the classic functions of the dplyr package: `select`, `group_by` et `summarize`. These functions also work with sf objects.
</details>


```{r, nm=TRUE, eval=FALSE, solution = TRUE}
library(dplyr)
com_31 <- iris_31 %>%
  select(INSEE_COM,P14_POP) %>%
  group_by(INSEE_COM) %>% 
  summarize(P14_POP= sum(P14_POP)) %>% 
  st_cast("MULTIPOLYGON")

plot(st_geometry(com_31))
```

```{r, nm=TRUE, echo=FALSE}
com_31 <- iris_31 %>%
  select(INSEE_COM,P14_POP) %>%
  group_by(INSEE_COM) %>% 
  summarize(P14_POP= sum(P14_POP)) %>% 
  st_cast("MULTIPOLYGON")

plot(st_geometry(com_31))
```

7.  Using the data contained in "sir_31", add to this layer the number of restaurants per municipality. 

```{block, box.title=" Information",box.type = "advice"}
The code of each municipality isn't in the "sir_31" database. To create it, you have to create a variable called INSEE_COM (5 digits) which concatenates the DEPET (2 digits) and COMET (3 digits) variables.
```

```{r, nm=TRUE, solution = TRUE}
sir_31 <- readRDS("../data/sir_31.rds")

com_31 <- left_join(com_31,
                    sir_31 %>%
  mutate(INSEE_COM=paste0(DEPET,COMET)) %>% 
  group_by(INSEE_COM) %>% 
   summarize(nb_of_rest= n()) %>% 
  st_set_geometry(NULL),
                    by=c("INSEE_COM"="INSEE_COM")
) %>% 
  mutate(nb_of_rest=ifelse(is.na(nb_of_rest),0,nb_of_rest))
```

8. Aggregate all the information present in "com_31" at the level of french intercommunalites (called EPCI). 

```{block, box.title=" Information",box.type = "advice"}
You have to use the database "table_MAUP.rds" to have a match between the municipality code (CODGEO) and intercommunality code (EPCI).
```


```{r, nm=TRUE, eval=FALSE, solution = TRUE}
table_MAUP <- readRDS("../data/table_MAUP.rds") %>% 
  select(CODGEO,EPCI)

epci_31  <- com_31 %>%
  left_join(table_MAUP,by=c("INSEE_COM"="CODGEO")) %>% 
  group_by(EPCI) %>% 
  summarize(P14_POP=sum(P14_POP),nb_of_rest= sum(nb_of_rest)) %>% 
  st_cast("MULTIPOLYGON")

plot(st_geometry(epci_31))
```


```{r, nm=TRUE, echo=FALSE}
table_MAUP <- readRDS("../data/table_MAUP.rds") %>% 
  select(CODGEO,EPCI)

epci_31  <- com_31 %>%
  left_join(table_MAUP,by=c("INSEE_COM"="CODGEO")) %>% 
  group_by(EPCI) %>% 
  summarize(P14_POP=sum(P14_POP),nb_of_rest= sum(nb_of_rest)) %>% 
  st_cast("MULTIPOLYGON")

plot(st_geometry(epci_31))
```


```{block, box.title="Information",box.type = "advice"}
We can notice that the number of restaurants is very low or even equals to zero in most municipalities. We will therefore want to create a new map layer that partially uses the zoning of the municipalities and partially the EPCI zoning.
```

9. We want to map the number of restaurants at the level of municipalities if its EPCI (intercommunality) contains more than 100 restaurants and at the level of intercommunalities if the intercommunality contains less than 100 restaurants. Create a map layer that meets this need.

<details>
<summary style="color:orange;font-family:courier;font-size:150%"><b>CLUES</b></summary>
Start by creating the layers EPCI_less100 and COM_more100 corresponding respectively to the EPCIs which contain less than 100 restaurants and to the municipalities which belong to an EPCI containing more than 100 restaurants. Then, use the `do.call(rbind, list(EPCI_less100,COM_more100))` statement to merge them.
</details>


```{r, nm=TRUE, eval=FALSE, solution = TRUE}
EPCI_less100 <- epci_31 %>% filter(nb_of_rest < 100) %>% 
  setNames(c("territory","P14_POP","nb_of_rest","geometry"))

COM_more100 <- left_join(com_31,table_MAUP,by=c("INSEE_COM"="CODGEO")) %>% 
  filter(!EPCI%in%EPCI_less100$territory) %>% 
  select(-EPCI) %>% 
  setNames(c("territory","P14_POP","nb_of_rest","geometry"))

par(mar = c(0,0,0,0), mfrow = c(1,2))
plot(st_geometry(epci_31))
plot(st_geometry(EPCI_less100), col="lightblue",add=TRUE)
plot(st_geometry(epci_31))
plot(st_geometry(COM_more100), col="lightblue",add=TRUE)

mix_31 <- do.call(rbind, list(EPCI_less100,COM_more100))

plot(st_geometry(mix_31), col="lightblue")
```

####{.tabset}

##### Municipalities
```{r, nm=TRUE, echo=FALSE}
EPCI_less100 <- epci_31 %>% filter(nb_of_rest < 100) %>% 
  setNames(c("territory","P14_POP","nb_of_rest","geometry"))

COM_more100 <- left_join(com_31,table_MAUP,by=c("INSEE_COM"="CODGEO")) %>% 
  filter(!EPCI%in%EPCI_less100$territory) %>% 
  select(-EPCI) %>% 
  setNames(c("territory","P14_POP","nb_of_rest","geometry"))

plot(st_geometry(epci_31))
plot(st_geometry(EPCI_less100), col="lightblue",add=TRUE)
```

##### Intercommunalities
```{r, nm=TRUE, echo=FALSE}
plot(st_geometry(epci_31))
plot(st_geometry(COM_more100), col="lightblue",add=TRUE)
```

##### Both
```{r, nm=TRUE, echo=FALSE}
mix_31 <- do.call(rbind, list(EPCI_less100,COM_more100))
plot(st_geometry(mix_31), col="lightblue")
```

####{}

10. Using the {cartography} package, simply add to each territory of this map a proportional circle layer related to the number of restaurants.

<details>
<summary style="color:orange;font-family:courier;font-size:150%"><b>CLUES</b></summary>
The `propSymbolsLayer` function allows you to draw proportional circles.
</details>


```{r, nm=TRUE, eval=FALSE, solution = TRUE}
library(cartography)
plot(st_geometry(mix_31), col = "ivory1", border = "ivory3",lwd =0.5,bg = "#FBEDDA")
propSymbolsLayer(mix_31, var = "nb_of_rest", inches = 0.2)
```

```{r, nm=TRUE, echo=FALSE}
library(cartography)
plot(st_geometry(mix_31), col = "ivory1", border = "ivory3",lwd =0.5,bg = "#FBEDDA")
propSymbolsLayer(mix_31, var = "nb_of_rest", inches = 0.2)
```

```{r, nm=TRUE, echo=FALSE, eval=FALSE}
#Sauvegarde des objets pour les exercices suivants
#saveRDS(object = epci_31, file = "../data/epci_31.rds")
#saveRDS(object = com_31, file = "../data/com_31.rds")
#saveRDS(object = mix_31, file = "../data/mix_31.rds")
```

# Exercise 2 : Map with cartography and ggplot2 packages

1. Data preparation:

* Load in R "fra.shp": the map layer of the borders of the French metropolitan territory 
* Load the layer called "mix_31.rds" (see previous exercise for more details) and create a variable called "nb_rest_10000inhab" which corresponds to the number of restaurants per 10,000 inhabitants in each territory
* Create the vector "bks" which corresponds to the breaks of the quantiles (n = 6) of the variable called "nb_rest_10000inhab" and remove duplicated elements in this vector
* Create the vector "cols" which corresponds to a orange sequential palette (n = 4)
* Finally, add to the layer "mix_31" a variable called "typo" which indicates the class of the territory according to the discretization contained in "bks" for the  "nb_rest_10000inhab" variable.


```{block, box.title="Information",box.type = "advice"}
For the creation of bks et cols, use the `getBreaks` et `carto.pal` functions of the  {cartography} package.
For the creation of the "typo" variable, you can use the `cut` function and apply the parameters digit.lab = 2 and include.lowest = TRUE.
```

```{r, solution=TRUE}
library(sf)
library(cartography)

fra <- st_read("../data/fra.shp", quiet = TRUE)

mix_31 <- readRDS("../data/mix_31.rds")
mix_31 <- mix_31 %>% mutate(nb_rest_10000inhab = 10000 * nb_of_rest / P14_POP) 

bks <- getBreaks(v = mix_31$nb_rest_10000inhab, method = "quantile", nclass = 6)[-c(1:2)]

cols <- carto.pal("orange.pal", 4)

mix_31 <- mix_31 %>% mutate(typo = cut(nb_rest_10000inhab,breaks = bks, dig.lab = 2, include.lowest = TRUE))
```

2. With the help of {cartography} package, make the following map which contains in a choropleth layer the variable "nb_rest_10000inhab" and in a proportional circle layer the variable "nb_of_rest". Do the same thing with the ggplot2 package.

####{.tabset}

##### cartography
```{r, nm=TRUE, echo=FALSE}
par(mar = c(0.2, 0.2, 1.4, 0.2), bg = "azure")
plot(st_geometry(mix_31), border="azure")
plot(st_geometry(fra), col="ivory", border = "ivory3", xlim = bb[c(1, 3)], 
     ylim = bb[c(2, 4)],add=TRUE)

choroLayer(mix_31, var = "nb_rest_10000inhab", breaks = bks, col = cols, border = "grey80", lwd = 0.4, 
           legend.pos = "topleft", legend.title.txt = "Number of restaurants\nfor 10000 inhabitants", 
           add = TRUE)
propSymbolsLayer(mix_31, var="nb_of_rest", col=viridis::viridis(1,alpha=0.8),border=NA, legend.pos="left", legend.title.txt = "Number of restaurants", add = TRUE)
layoutLayer(title = "Restaurants", sources = "Insee, 2018", author = "Kim & Tim, 2018", 
            theme = "green.pal", col = "darkred", coltitle = "white", postitle = "center",
            frame = TRUE, scale = 10)
north(pos = "topright", south = TRUE)
```

##### ggplot2
```{r, nm=TRUE, echo=FALSE}
library(ggplot2)

map_ggplot <- ggplot() +
  geom_sf(data = fra, colour = "ivory3",
          fill = "ivory") +
  geom_sf(data = mix_31, aes(fill = typo), colour = "grey80") +
  scale_fill_manual(name = "Number of restaurants\nfor 10000 inhabitants",
                    values = cols, na.value = "#303030")+
   geom_sf(data = mix_31 %>%  st_centroid(),
           aes(size= nb_of_rest), color = viridis::viridis(1,alpha=0.8), show.legend = 'point')+
  scale_size(name = "Number of restaurants",
             breaks = c(1, 500, 2000),
             range = c(0,18))+
  coord_sf(crs = 2154, datum = NA,
           xlim = st_bbox(mix_31)[c(1,3)],
           ylim = st_bbox(mix_31)[c(2,4)]
  ) +
  theme_minimal() +
  theme(panel.background = element_rect(fill = "azure",color=NA)) +
  labs(
      title = "Restaurants",
      caption = "Insee, 2018\nKim & Tim, 2018"
  )

plot(map_ggplot)
```

####{}

With cartography :

```{r, eval=FALSE, solution=TRUE}
par(mar = c(0.2, 0.2, 1.4, 0.2), bg = "azure")
plot(st_geometry(mix_31), border="azure")
plot(st_geometry(fra), col="ivory", border = "ivory3", xlim = bb[c(1, 3)], 
     ylim = bb[c(2, 4)],add=TRUE)

choroLayer(mix_31, var = "nb_rest_10000inhab", breaks = bks, col = cols, border = "grey80", lwd = 0.4, 
           legend.pos = "topleft", legend.title.txt = "Number of restaurants\nfor 10000 inhabitants", 
           add = TRUE)
propSymbolsLayer(mix_31, var="nb_of_rest", col=viridis::viridis(1,alpha=0.8),border=NA, legend.pos="left", legend.title.txt = "Number of restaurants", add = TRUE)
layoutLayer(title = "Restaurants", sources = "Insee, 2018", author = "Kim & Tim, 2018", 
            theme = "green.pal", col = "darkred", coltitle = "white", postitle = "center",
            frame = TRUE, scale = 10)
north(pos = "topright", south = TRUE)
```

With ggplot2 :

```{r, eval=FALSE, solution=TRUE}
library(ggplot2)

map_ggplot <- ggplot() +
  geom_sf(data = fra, colour = "ivory3",
          fill = "ivory") +
  geom_sf(data = mix_31, aes(fill = typo), colour = "grey80") +
  scale_fill_manual(name = "Number of restaurants\nfor 10000 inhabitants",
                    values = cols, na.value = "#303030")+
   geom_sf(data = mix_31 %>%  st_centroid(),
           aes(size= nb_of_rest), color = viridis::viridis(1,alpha=0.8), show.legend = 'point')+
  scale_size(name = "Number of restaurants",
             breaks = c(1, 500, 2000),
             range = c(0,18))+
  coord_sf(crs = 2154, datum = NA,
           xlim = st_bbox(mix_31)[c(1,3)],
           ylim = st_bbox(mix_31)[c(2,4)]
  ) +
  theme_minimal() +
  theme(panel.background = element_rect(fill = "azure",color=NA)) +
  labs(
      title = "Restaurants",
      caption = "Insee, 2018\nKim & Tim, 2018"
  )

plot(map_ggplot)
```


# Exercise 3 : Smooth Density analysis of restaurants in Haute-Garonne

```{block,box.title="Remarques pour Timothée et Kim",box.colour="#FF0099"}
Pour Timothée, élements des fonctions fufun et fufun2 à modifier : 

* Leurs noms...
* Remplacer bks - 1 par bks dans fufun2 et enlever  rasdens <- rasdens + 1
* Créer un paramètre pour la légende pour pouvoir adapter à la carte (500m pour le cours sur Paris et 5km pour la Haute-Garonne pour l'exo)
* Dans la fonction fufun, ne pas faire de st_intersection mais un st_intersect afin de ne pas avoir tout le rectangle autour de la Haute Garonne mais seulement les carrés de la grille de Haute-Garonne. 
* Mettre des cex = 1 dans les deux fonctions (fufun et fufun2) pour avoir les mêmes légendes ? Ou, si ça fait pas beau dans la partie cours, rajouter en paramètre des fonctions fufun et fufun2. 
* Dans fufun2 : changer la méthode pour enlever les 0 du calcul des quantiles.

Puis Kim : adapter cet exo 3 avec ces nouvelles fonctions. 
```

1. Load the dataset "sir_31" used previously and map the more than 4,000 restaurants of department 31 with the {mapview} package. Try using different parameters to customize your map.


```{block, box.title=" Information",box.type = "advice"}
For example, you can use the map.types, col.regions, label, color, legend, layer.name, homebutton, lwd ... parameters of the `mapview` function.
```


```{r, nm=TRUE, eval=FALSE, solution=TRUE}
library(mapview)
library(sf)
library(cartography)
sir_31 <- readRDS("../data/sir_31.rds")

mapview(sir_31, map.types = "OpenStreetMap", col.regions = "#940000", label = paste(sir_31$L2_NORMALISEE, sir_31$NOMEN_LONG, sep = " - "), color = "white", legend = TRUE, layer.name = "Restaurants in SIRENE", homebutton = FALSE, lwd = 0.5) 
```


```{r, nm=TRUE, echo=FALSE}
library(mapview)
library(sf)
library(cartography)
sir_31 <- readRDS("../data/sir_31.rds")

mapview(sir_31, map.types = "OpenStreetMap", col.regions = "#940000", label = paste(sir_31$L2_NORMALISEE, sir_31$NOMEN_LONG, sep = " - "), color = "white", legend = TRUE, layer.name = "Restaurants in SIRENE", homebutton = FALSE, lwd = 0.5) 
```

2. Load the layer "iris_31" used previously and apply the fufun2 function below on the SIRENE data and on the iris of the department 31. Use a 2km cellsize. What observation can you make concerning the readability of the map?

```{r, box.title=" Information",box.type = "advice"}
fufun2 <- function(feat, adm, cs = 500, method="equal",nclass=12, author="") {
  grid <- st_make_grid(x = adm, cellsize = cs, what = "polygons")
  x <- st_intersects(grid, feat) 
  gg <- st_sf(n = sapply(X = x, FUN = length), grid)
  gg <- st_intersection(gg,adm) #NEW
  plot(adm$geometry, col = NA, border = NA, main="", bg = "#FBEDDA")
  bks <- c(0,unique(round(getBreaks(gg$n[gg$n>0], nclass = nclass, method = method),0)))
  cols <- (mapview::mapviewGetOption("raster.palette"))(length(bks) - 1)
  choroLayer(gg, var = "n", border = NA, add = TRUE, method = method, breaks= bks, col= cols, legend.pos="topright", legend.values.cex=0.7, legend.title.cex=0.7, legend.title.txt = "resto per ha", legend.nodata=FALSE,legend.values.rnd=0)
  layoutLayer(title = "Count points in a regular grid", scale = 0.5, tabtitle = TRUE, frame = FALSE, sources = "Insee, SIRENE 2018", author = author)
}
```

```{r, nm=TRUE, eval=TRUE, echo=FALSE}
fufun2 <- function(feat, adm, cs = 500, method="equal",nclass=12, author="") {
  grid <- st_make_grid(x = adm, cellsize = cs, what = "polygons")
  x <- st_intersects(grid, feat) 
  gg <- st_sf(n = sapply(X = x, FUN = length), grid)
  gg <- st_intersection(gg,adm) #NEW
  plot(adm$geometry, col = NA, border = NA, main="", bg = "#FBEDDA")
  bks <- c(0,unique(round(getBreaks(gg$n[gg$n>0], nclass = nclass, method = method),0)))
  cols <- (mapview::mapviewGetOption("raster.palette"))(length(bks) - 1)
  choroLayer(gg, var = "n", border = NA, add = TRUE, method = method, breaks= bks, col= cols, legend.pos="topright", legend.values.cex=0.7, legend.title.cex=0.7, legend.title.txt = "resto per ha", legend.nodata=FALSE,legend.values.rnd=0)
  layoutLayer(title = "Count points in a regular grid", scale = 0.5, tabtitle = TRUE, frame = FALSE, sources = "Insee, SIRENE 2018", author = author)
}
```

```{r, sm=TRUE, solution=TRUE}
iris_31 <- readRDS("../data/iris_31.rds")
fufun2(sir_31, iris_31, 2000)
# La carte est peu lisible en raison du choix de discrétisation
```

3. Try to make a more readable map.

<details>
<summary style="color:orange;font-family:courier;font-size:150%"><b>CLUES</b></summary>
Test the method = "quantile" parameter and vary the number of classes until you get something nice.
</details>

```{r, nm=TRUE, eval=FALSE, solution=TRUE}
fufun2(sir_31, iris_31, 2000,method="quantile",nclass=20)
```

```{r, sm=TRUE, echo=FALSE}
fufun2(sir_31, iris_31, 2000,method="quantile",nclass=20)
```

4. In order to make the result even more meaningful, we will now make a smoothed map. You can use the fufun function below. Use a 2km sigma and a 2km resolution and the quantile method (n = 12). 


```{r, box.title=" Information",box.type = "advice"}
library(spatstat)
library(raster)
library(maptools)
fufun <- function(feat, adm, sigma = 100, res = 50, method="equal",nclass=12, author="") {
  bb <- as(feat, "Spatial")
  bbowin <- as.owin(as(adm, "Spatial"))
  pts <- coordinates(bb)
  p <- ppp(pts[, 1], pts[, 2], window = bbowin)
  ds <- density.ppp(p, sigma = sigma, eps = res)
  rasdens <- raster(ds) * 10000 * 10000
  proj4string(rasdens) <- "+init=epsg:2154"
  bks <- unique(round(getBreaks(values(rasdens), nclass = nclass, method = method),0)) 
  cols <- (mapview::mapviewGetOption("raster.palette"))(length(bks) - 1)
  plot(adm$geometry, col = NA, border = NA, main = "", bg = "#FBEDDA")
  plot(rasdens, breaks = bks, col = cols, add = T, legend = F)
  legendChoro(pos = "topright", cex = 0.7, title.cex = 0.7, title.txt = "resto per ha", 
              breaks = bks, nodata = FALSE, values.rnd = 0, col = cols)
  layoutLayer(title = "Smooth density Analysis", scale = 0.5, tabtitle = TRUE, frame = FALSE, sources = "Insee, SIRENE 2018", author = author)
 }
```


```{r, nm=TRUE, eval=TRUE, echo=FALSE}
library(spatstat)
library(raster)
library(maptools)
fufun <- function(feat, adm, sigma = 100, res = 50, method="equal",nclass=12, author="") {
  bb <- as(feat, "Spatial")
  bbowin <- as.owin(as(adm, "Spatial"))
  pts <- coordinates(bb)
  p <- ppp(pts[, 1], pts[, 2], window = bbowin)
  ds <- density.ppp(p, sigma = sigma, eps = res)
  rasdens <- raster(ds) * 10000 * 10000
  proj4string(rasdens) <- "+init=epsg:2154"
  bks <- unique(round(getBreaks(values(rasdens), nclass = nclass, method = method),0)) 
  cols <- (mapview::mapviewGetOption("raster.palette"))(length(bks) - 1)
  plot(adm$geometry, col = NA, border = NA, main = "", bg = "#FBEDDA")
  plot(rasdens, breaks = bks, col = cols, add = T, legend = F)
  legendChoro(pos = "topright", cex = 0.7, title.cex = 0.7, title.txt = "resto per ha", 
              breaks = bks, nodata = FALSE, values.rnd = 0, col = cols)
  layoutLayer(title = "Smooth density Analysis", scale = 0.5, tabtitle = TRUE, frame = FALSE, sources = "Insee, SIRENE 2018", author = author)
 }
```


```{r, sm=TRUE, solution=TRUE}
fufun(sir_31, iris_31,  2000, 2000,method="quantile",nclass=12)
```

5. Try to improve the map resolution.

```{r, nm=TRUE, eval=FALSE, solution=TRUE}
fufun(sir_31, iris_31,  2000, 500,method="quantile",nclass=12)
```

```{r, sm=TRUE, echo=FALSE}
fufun(sir_31, iris_31,  2000, 500,method="quantile",nclass=12)
```

6. Would we have obtained the same smoothing for this department if we had kept the restaurants of the bordering departments?

```{block, solution = TRUE}
No. The borders would have been different. 
```


# Exercise 4 : Cartogram

Make a cartogram of department 31 at the level of intercommunalities in proportion to the number of restaurants (SIRENE data).

```{block, box.title=" Information",box.type = "advice"}
Load the layer "epci_31.rds" from previous exercises and the {cartogram} package. 
```


```{r, nm=TRUE, eval=FALSE, solution = TRUE}
epci_31 <- readRDS("../data/epci_31.rds")

library(cartogram)
library(sf)

cartogramme <- cartogram_cont(epci_31, "nb_of_rest", itermax = 5, maxSizeError = 1)
plot(st_geometry(cartogramme), col="lightblue")
```

####{.tabset}

##### Normal borders
```{r, nm=TRUE, echo=FALSE}
epci_31 <- readRDS("../data/epci_31.rds")

library(sf)
plot(st_geometry(epci_31), col="lightblue")
```

##### Cartogram
```{r, nm=TRUE, echo=FALSE}
library(cartogram)
cartogramme <- cartogram_cont(epci_31, "nb_of_rest", itermax = 5, maxSizeError = 1)
plot(st_geometry(cartogramme), col="lightblue")
```

####{}


# Exercise 5 : Linemap

Make a linemap of department 31 at the level of municipalities in proportion to the number of restaurants (SIRENE data).

```{block, box.title=" Information",box.type = "advice"}
Load the map layer "com_31.rds" from previous exercises and the {linemap} package. 
```

<details>
<summary style="color:orange;font-family:courier;font-size:150%"><b>CLUES</b></summary>
Use the two `getgrid` and` linemap` functions of this package.
The following parameters work: cellsize = 1750, k = 400 and threshold = 0.01.
</details>


```{r, nm=TRUE, eval=FALSE, solution = TRUE}
com_31 <- readRDS("../data/com_31.rds")

library(linemap)
grid <- getgrid(x = com_31, cellsize = 1750, var = "nb_of_rest")
plot(sf::st_geometry(com_31), col="ivory1", border = NA)
opar <- par(mar=c(0,0,0,0), bg = "ivory2")
linemap(x = grid, var = "nb_of_rest", k = 400, threshold = 0.01,
        col = "ivory1", border = "ivory4", lwd = 0.6, add = TRUE)
```

```{r, nm=TRUE, echo=FALSE}
com_31 <- readRDS("../data/com_31.rds")

library(linemap)
grid <- getgrid(x = st_transform(com_31, crs=st_crs(occitanie)), cellsize = 1750, var = "nb_of_rest")
plot(sf::st_geometry(st_transform(com_31, crs=st_crs(occitanie))), col="ivory1", border = NA)
opar <- par(mar=c(0,0,0,0), bg = "ivory2")
linemap(x = grid, var = "nb_of_rest", k = 400, threshold = 0.00001,
        col = "ivory1", border = "ivory4", lwd = 0.6, add = TRUE)
library(dplyr) #because select is also in raster package and bugs if CACHE = TRUE
```




--------------------------------------------

--------------------------------------------

**reproducibility**

```{r}
sessionInfo()
```
