---
title: "LET'S PRACTICE Geovisualization and Spatial Analysis "
author: "Kim Antunez & Timothée Giraud"
date: "Massive spatial data: challenges in acquisition, treatment and use for territories"
output: 
  html_document: 
    number_sections: yes
    code_folding: hide # or none
    theme: journal
---


```{r knitr_init, echo=FALSE, cache=FALSE, include=FALSE}
library(knitr)
## Global options
options(max.print="90")
opts_chunk$set(echo=TRUE,
	             cache=FALSE,
               prompt=FALSE,
               tidy=FALSE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=90)
options(width = 90)

# no margins
knit_hooks$set(nm = function(before, options, envir){
  if (before){
    par(mar=c(0,0,0,0))
  } 
})

# title margins
knit_hooks$set(sm = function(before, options, envir){
  if (before){
    par(mar=c(0,0,1.2,0))
  } 
})


```

# Exercice 1 : Manipuler les objets sf et des data.frames associés

1. Charger la couche cartographique des iris du département 31 "iris_31.rds" dans R. Est-ce que la fonction `sf::st_read` fonctionnerait également ? Pourquoi ?

<details>
<summary style="color:orange;font-family:courier;font-size:150%"><b>CLUES</b></summary>
Utilisez la fonction `readRDS`.
</details>

```{r}
library(sf)
iris_31 <- readRDS("data/iris_31.rds")
# iris_31 <- st_read("data/iris_31.rds")
# Cela ne fonctionne pas car il ne s'agit pas d'un shapefile mais d'un fichier déjà mis au format R. Il suffit 
# alors simplement de le charger avec la fonction readRDS.

```


2. Afficher simplement le fond de carte du département 31 avec l'instruction `plot(iris_31)`.
Que remarquez-vous ? 


```{r, nm=TRUE}
plot(iris_31)
# On remarque que R effectue un graphique par variable présent dans le fichier sf, ici 3.


```


3. Quel est le rôle de la fonction `sf::st_geometry` ? Quelle solution proposez-vous alors ? 

```{r, nm=TRUE}
# ?sf::st_geometry
# Cette fonction permet d'isoler les informations de l'objet sf relatives à sa géométrie et d'ainsi mettre de côté les autres variables ici CODE_IRIS, P14_POP et INSEE_COM
plot(st_geometry(iris_31))
```

4. En quelle projection est la couche cartographique ? Cartographiez-la dans une autre projection. 

<details>
<summary style="color:orange;font-family:courier;font-size:150%"><b>CLUES</b></summary>
Utilisez la fonction `sf::st_crs` pour deviner la projection et `sf::st_transform` pour changer la projection.
</details>


```{r, nm=TRUE}
#?st_crs
st_crs(iris_31)
par(mar = c(0,0,0,0), mfrow = c(1,2))
plot(st_geometry(iris_31))
plot(st_transform(st_geometry(iris_31), crs="+proj=aeqd +lat_0=90 +lon_0=0"))
```

5. A partir de la couche "iris_31", créez une couche cartographique appelée "com_31" qui correspond aux communes du département 31. Gardez également dans cette nouvelle couche les informations sur la population présente dans chaque commune. 

Info : La couche cartographique "iris_31"" contient les codes communes dans sa variable INSEE_COM et la population municipale de 2014 dans sa variable P14_POP.


<details>
<summary style="color:orange;font-family:courier;font-size:150%"><b>CLUES</b></summary>
Utilisez les fonctions classiques du package dplyr `select`, `group_by` et `summarize` qui s'appliquent aussi sur des objets de type sf.
</details>


```{r, nm=TRUE}
library(dplyr)
com_31 <- iris_31 %>%
  select(INSEE_COM,P14_POP) %>%
  group_by(INSEE_COM) %>% 
  summarize(P14_POP= sum(P14_POP))
plot(st_geometry(com_31))
#Timothée : peut-on le faire aussi avec st_union ou st_union ne permet pas le group_by ?
```

6. En utilisant les données contenues dans "sir_31", ajoutez à cette couche le nombre de restaurants par commune. 
Info : Le code commune n'est pas présent dans la base "sir_31". Pour l'obtenir, il faut créer une variable INSEE_COM (5 chiffres) qui contatène les variables DEPET (2 chiffres) et COMET (3 chiffres).

```{r, nm=TRUE}
sir_31 <- readRDS("data/sir_31.rds")

com_31 <- left_join(com_31,
                    sir_31 %>%
  mutate(INSEE_COM=paste0(DEPET,COMET)) %>% 
  group_by(INSEE_COM) %>% 
   summarize(nb_of_rest= n()) %>% 
  st_set_geometry(NULL),
                    by=c("INSEE_COM"="INSEE_COM")
) %>% 
  mutate(nb_of_rest=ifelse(is.na(nb_of_rest),0,nb_of_rest))
                    
  
```

7. Agrégez toutes les informations présentes dans "com_31" au niveau des intercommunalités (EPCI). 
Info : Il faut utiliser la table de passage "table_MAUP.rds" pour avoir une correspondance entre le code communal (CODGEO) et le code de l'intercommunalité (EPCI).
 

```{r, nm=TRUE}
table_passage <- readRDS("data/table_MAUP.rds") %>% 
  select(CODGEO,EPCI)

epci_31  <- com_31 %>%
  left_join(table_passage,by=c("INSEE_COM"="CODGEO")) %>% 
  group_by(EPCI) %>% 
  summarize(P14_POP=sum(P14_POP),nb_of_rest= sum(nb_of_rest))
# Timothée : peut-on le faire aussi avec st_union ou st_union ne permet pas le group_by ?
```


Info : On peut remarquer que le nombre de restaurants est très faible voire nul dans la plupart des communes.   


```{r, nm=TRUE}
library(ggplot2)
histo <- ggplot(com_31 , aes(x = nb_of_rest)) +
    stat_bin(breaks=c(0,10,20,50,2500),colour = "goldenrod2", fill = "gold1") +
    scale_x_continuous(name = "Number of restaurants in the municipality") +
    stat_bin(breaks=c(0,10,20,50,2500), geom="text", aes(label=ifelse(..count..!=0,..count..,""), vjust=-0.1))
plot(histo)

epci_31 %>% st_set_geometry(NULL) %>% arrange(desc(nb_of_rest))


```


8. On va donc vouloir cartographier le nombre de restaurants au niveau communal si son EPCI contient plus de 100 restaurants et au niveau intercommunal si l'EPCI contient moins de 100 restaurants. Créez une couche cartographique qui réponde à ce besoin. 

<details>
<summary style="color:orange;font-family:courier;font-size:150%"><b>CLUES</b></summary>
Commencez par créer les couches EPCI_less100 et COM_more100 qui correspondent respectivement aux EPCI qui contiennent moins de 100 restaurants et aux communes qui appartiennent à un EPCI contenant plus de 100 restaurants. 
Puis, utilisez l'instruction `do.call(rbind, list(EPCI_less100,COM_more100))` pour les fusionner.
</details>


```{r, nm=TRUE}
EPCI_less100 <- epci_31 %>% filter(nb_of_rest < 100) %>% 
  setNames(c("territory","P14_POP","nb_of_rest","geometry"))

COM_more100 <- left_join(com_31,table_passage,by=c("INSEE_COM"="CODGEO")) %>% 
  filter(!EPCI%in%EPCI_less100$territory) %>% 
  select(-EPCI) %>% 
  setNames(c("territory","P14_POP","nb_of_rest","geometry"))

par(mar = c(0,0,0,0), mfrow = c(1,2))
plot(st_geometry(epci_31))
plot(st_geometry(EPCI_less100), col="lightblue",add=TRUE)
plot(st_geometry(epci_31))
plot(st_geometry(COM_more100), col="lightblue",add=TRUE)

mix_31 <- do.call(rbind, list(EPCI_less100,COM_more100))

plot(st_geometry(mix_31), col="lightblue")

```

9. A l'aide du package {cartography}, ajoutez simplement à cette carte un rond proportionnel au nombre de restaurants sur chacun de ces territoires.

<details>
<summary style="color:orange;font-family:courier;font-size:150%"><b>CLUES</b></summary>
C'est la fonction `propSymbolsLayer` qui permet de dessiner des ronds proportionnels. 
</details>


```{r, nm=TRUE}
library(cartography)
plot(st_geometry(mix_31), col = "ivory1", border = "ivory3",lwd =0.5)
propSymbolsLayer(mix_31, var = "nb_of_rest", inches = 0.2)
```


# Exercice 2 : Cartographie statique et interactive

Réaliser une carte avec tous les packages présentés par Timothée. En attente de la partie de Timothée sur le sujet pour m'en inspirer !

# Exercices 3 à X : Traitements avancés de cartographie

L'idée ici serait de faire plusieurs exercices courts à la fin (pour les plus avancés ?) sur des choses marrantes à faire, indépendamment de ce que l'on montrerait en "cours".
J'ai pensé à quelques idées : 

 * un cartogramme (je crois que c'est le nom scientifique pour anamorphose, tu me confirmeras !)
 * une carte avec variable à trois couleurs (ça aussi ça doit avoir un nom mais mes connaissances s'arrêtent là ;) comme [ici](https://github.com/ikashnitsky/the-lancet-2018)




--------------------------------------------

--------------------------------------------

**reproducibility**

```{r}
sessionInfo()
```
